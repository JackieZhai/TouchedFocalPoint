# 数据集说明
1. 将体素数大于82944的超体素块抽取出来进行运算。
（因为小块数量过多，符合此条件的有1413个，而总数有13000个以上太难进行比对）
2. 计算超体素标号、体素数，保存到"count_bigbig.txt"中。
3. 计算超体素与那些超体素近邻，保存到"pair_dic_bigbig"中。
（所谓近邻即是在任意32*32*3[96nm*96nm*90nm]方块中同时存在两者的体素）
4. "origin.npy"是原始数据矩阵（2048*2048*300，所有文件保存的时候都是按z、y、x坐标反向保存的）。

# 算法说明
1. 遍历，将矩阵转化为超体素各点坐标, 同时进行空心化，保存在"piece_bigbig"中。
2. 使用TEASAR算法（Google洪水网络论文中使用的同样方法）得到无杂乱分叉的skeleton结果，以坐标的形式保存在"skeleton_bigbig"中。
3. 借助skeleton信息划定特定区域，寻找接触面（必要时需进行采样），并根据skeleton判断切线。
### 保存格式
* "sur_dic_bigbig"->主超体素编号->所接触的超体素编号->结果
### 结果格式
* sur_dic.csv 主超体素接触面
* sur_to.csv 所接触的超体素接触面
* ske_dic.csv 主超体素接触部分的骨架(最近的100个点)
* ske_to.csv 所接触的超体素接触部分的骨架(最近的100个点)
* fit_dicto.csv 两个拟合的直线向量(第一个是主超体素接触部分的骨架的切线，第二个是所接触超体素接触部分的骨架的切线)

# 数据格式
1. 矩阵均存为.csv格式，MATLAB、Python、C++都容易打开。
2. 保存矩阵为[[z, y, x], ...]格式，其中单位都是nm，返回图上需[/30 /3 /3]。
3. z表示张数(0, 300)、y表示上下宽度(0, 2048)、x表示左右长度(0, 2048)。
